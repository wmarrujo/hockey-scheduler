from pulp import *
from math import floor
import os
#import platform

################################################################################
# MODEL
################################################################################

def solveModel(data):
    # get data
    sets = makeSets(data)
    values = makeValues(data, sets)
    
    variables = makeVariables(sets, values)
    objective = makeObjective(sets, values, variables)
    constraints = makeConstraints(sets, values, variables)
    
    # make model
    model = LpProblem("Model", LpMinimize)
    model += objective
    for constraint in constraints:
        model += constraint[0], constraint[1]
    
    # solve model
    solver = COIN_CMD(path=getCBCPath(), msg=0)
    model.solve(solver)
    
    print("Solver finished with status \"{}\".".format(describeStatus(model)))
    
    # get solution
    return variables |> fmap$((name, vs) -> (name, vs |> fmap$((index, variable) -> (index, value(variable)))))

def getCBCPath():
    dirname = os.path.dirname(__file__)
    
    # TODO: make dynamic
    return os.path.abspath(os.path.join(dirname, "../assets/osx/64/cbc"))

def describeStatus(model):
    if model.status == 0: return "solver has not finished running"
    elif model.status == 1: return "Optimal solution found"
    elif model.status == -1: return "The problem is infeasible"
    elif model.status == -2: return "The problem is unbounded"
    elif model.status == -3: return "The solution is undefined"

################################################################################
# SETS
################################################################################

def makeSets(data):
    # get teams
    teams = data |> .keys() |> set
    
    # get rinks
    rinks = data \
        |> fmap$((team, values) -> (team, values["ice-time"])) \ # get only the ice times per teaam
        |> .values() |> list \ # get a list of lists of ice times
        |> reduce$(+) \ # concatenate all individual team lists
        |> fmap$(.["rink"]) \ # get the rinks
        |> set # remove duplicates
    
    # get slots
    slots = data \
        |> fmap$((team, values) -> (team, values["ice-time"])) \ # get only the ice times per teaam
        |> .values() |> list \ # get a list of lists of ice times
        |> reduce$(+) \ # concatenate all individual team lists
        |> fmap$(.["time"]) \ # get the rinks
        |> fmap$(.date()) \ # turn into dates
        |> set # remove duplicates
    
    # get weeks
    earliestDay = min(slots)
    weeks = slots |> fmap$(slot -> floor(((slot - earliestDay).days + earliestDay.weekday()) / 7))
    
    return {
        "teams": teams, # [team]
        "rinks": rinks, # [rink]
        "slots": slots, # [slot]
        "weeks": weeks # [week]
    }

################################################################################
# VALUES
################################################################################

def makeValues(data, sets):
    # get team home rink slots
    home = data |> fmap$((team, values) -> (team, values["ice-time"] |> fmap$(value -> (value["time"].date(), value["rink"]))))
    
    # get team slot availability
    unavailability = data |> fmap$((team, values) -> (team, values["unavailable"]))
    
    # get time slot day indices
    earliestDay = min(sets["slots"])
    days = sets["slots"] |> fmap$(slot -> (slot, (slot - earliestDay).days)) |> dict
    
    # get time slot week indices
    weeks = sets["slots"] |> fmap$(slot -> (slot, floor(((slot - earliestDay).days + earliestDay.weekday()) / 7))) |> dict
    
    return {
        "home": home, # {team: [(slot, rink)]}
        "unavailability": unavailability, # {team, [slot]}
        "days": days, # {slot: integer}
        "weeks": weeks # {slot: week}
    }

################################################################################
# VARIABLES
################################################################################

def makeVariables(sets, values):
    # whether a team is playing at a given rink at a given time
    playing = LpVariable.dicts("p", [(t, r, s) for t in sets["teams"] for r in sets["rinks"] for s in sets["slots"]], lowBound=0, cat=LpBinary)
    
    return {"playing": playing}

################################################################################
# OBJECTIVE
################################################################################

def makeObjective(sets, values, variables):
    return sum(values["days"][s] * variables["playing"][(t, r, s)] for t in sets["teams"] for r in sets["rinks"] for s in sets["slots"])

################################################################################
# CONSTRAINTS
################################################################################

def makeConstraints(sets, values, variables):
    # teams can only be in 1 rink at a time
    # & teams can only play 1 game per day
    # & teams can only play on days they're available
    conservation = [(sum(variables["playing"][(t, r, s)] for r in sets["rinks"]) <= (0 if s in values["unavailability"][t] else 1), "conservation[{},{}]".format(t, str(s))) for t in sets["teams"] for s in sets["slots"]]
    
    # only 2 games can be played per week
    covid = [(sum(variables["playing"][(t, r, s)] for t in sets["teams"] for r in sets["rinks"] for s in sets["slots"] if values["weeks"][s] == w) <= 2*2, "covid[{}]".format(w)) for w in sets["weeks"]]
    
    # games are between two teams, where one is the home team
    matchup = [(variables["playing"][(h, r, s)] == variables["playing"][(a, r, s)], "matchup[{},{},{},{}]".format(h,a,r,str(s))) for h in sets["teams"] for a in sets["teams"] for r in sets["rinks"] for s in sets["slots"] if h != a]
    
    # teams must host a game with each other team (double round robin)
    robin = [(sum(variables["playing"][(t, r, s)] * ((s, r) in values["home"][t]) for r in sets["rinks"] for s in sets["slots"]) >= 1, "robin[{}]".format(t)) for t in sets["teams"]]
    
    return [conservation, covid, matchup, robin] |> reduce$(+)
