from pulp import *
from math import floor
import os
#import platform

################################################################################
# MODEL
################################################################################

def solveModel(data):
    # get data
    sets = makeSets(data)
    values = makeValues(data, sets)
    
    variables = makeVariables(sets, values)
    objective = makeObjective(sets, values, variables)
    constraints = makeConstraints(sets, values, variables)
    
    # make model
    model = LpProblem("Model", LpMinimize)
    model += objective
    for name, constraint in constraints.items():
        model += constraint, name
    
    # solve model
    solver = COIN_CMD(path=getCBCPath(), msg=0)
    model.solve(solver)
    
    print("Solver finished with status \"{}\".".format(describeStatus(model)))
    
    # get solution
    return variables |> fmap$((name, vs) -> (name, vs |> fmap$((index, variable) -> (index, value(variable)))))

def getCBCPath():
    dirname = os.path.dirname(__file__)
    
    # TODO: make dynamic
    return os.path.abspath(os.path.join(dirname, "../assets/osx/64/cbc"))

def describeStatus(model):
    if model.status == 0: return "solver has not finished running"
    elif model.status == 1: return "Optimal solution found"
    elif model.status == -1: return "The problem is infeasible"
    elif model.status == -2: return "The problem is unbounded"
    elif model.status == -3: return "The solution is undefined"

################################################################################
# SETS
################################################################################

def makeSets(data):
    # get teams
    teams = data |> .keys() |> set
    
    iceTimes = data |> .values() |> list |> fmap$(item -> item["ice-time"]) |> reduce$(+) |> fmap$(iceTime -> (iceTime["rink"], iceTime["time"]))
    
    return {
        "T": teams, # [team]
        "I": iceTimes, # [(rink, time)]
    }

################################################################################
# VALUES
################################################################################

def makeValues(data, sets):
    # get team home rink slots
    def home(team, iceTime):
        return {"rink": iceTime[0], "time": iceTime[1]} in data[team]["ice-time"]
    
    # get team slot availability
    def availability(team, iceTime):
        return iceTime[1].date() not in data[team]["unavailable"]
    
    # get time slot day indices
    earliestDay = sets["I"] |> fmap$(iceTime -> iceTime[1]) |> min
    days = sets["I"] |> fmap$(iceTime -> (iceTime, floor((iceTime[1] - earliestDay).days))) |> dict
    
    # get time slot week indices
    weeks = sets["I"] |> fmap$(iceTime -> (iceTime, floor(((iceTime[1] - earliestDay).days + earliestDay.weekday()) / 7))) |> dict
    
    return {
        "H": home, # (team, iceTime) -> 1 or 0
        "A": availability, # (team, iceTime) -> 1 or 0
        "D": days, # {iceTime: integer}
        "W": weeks # {iceTime: integer}
    }

################################################################################
# VARIABLES
################################################################################

def makeVariables(sets, values):
    T = sets["T"]
    I = sets["I"]
    
    # whether a team is playing at a given rink at a given time
    playing = LpVariable.dicts("P", [(t, i) for t in T for i in I], lowBound=0, cat=LpBinary)
    
    return {"P": playing}

################################################################################
# OBJECTIVE
################################################################################

def makeObjective(sets, values, variables):
    T = sets["T"]
    I = sets["I"]
    D = values["D"]
    P = variables["P"]
    
    return sum(P[(t, i)] * D[i] for t in T for i in I)

################################################################################
# CONSTRAINTS
################################################################################

def makeConstraints(sets, values, variables):
    T = sets["T"]
    I = sets["I"]
    H = values["H"]
    A = values["A"]
    D = values["D"]
    W = values["W"]
    P = variables["P"]
    
    # teams can only play 1 game per day, when available
    conservation = {"conservation[{},{}]".format(t, i): \
        sum(P[(t, n)] for n in I if D[n] == D[i]) <= A(t, i) for t in T for i in I}
    
    # only 2 games can be played in the same week
    covid = {"covid[{},{}]".format(t, i): \
        sum(P[(t, n)] for n in I if W[n] == W[i]) <= 2 for t in T for i in I}
    
    # games are when 2 teams play at the same time
    games = {"games[{},{},{}]".format(h, a, i): \
        P[(h, i)] == P[(a, i)] for h in T for a in T for i in I if h != a}
    
    # a team can only play one other team at the same time
    matchup = {"matchup[{},{}]".format(h, i): \
        P[(h, i)] == sum(P[(a, i)] for a in T if h != a) for h in T for i in I}
    
    # a team cannot play on someone else's ice time without them
    mooch = {"mooch[{},{}]".format(a, h, i): \
        P[(a, i)] * H(h, i) == 0 for a in T for h in T for i in I if a != h}
    # FIXME: causes problem to be infeasible
    
    # two teams cannot play each other without one of them having ice time
    host = {"host[{},{},{}]".format(h, a, i): \
        P[(h, i)] + P[(a, i)] - (H(h, i) + H(a, i)) <= 1 for h in T for a in T for i in I}
    # FIXME: causes problem to be infeasible
    
    # each team must host each other team at least once
    robin = {"robin[{},{}]".format(h, a): \
        sum(P[(a, i)] for i in I if H(h, i)) >= 1 for h in T for a in T if h != a}
    
    return {**conservation, **covid, **games, **matchup, **mooch, **host, **robin}